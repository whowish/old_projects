<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>XmlSimple Tutorial</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="author" content="Maik Schmidt">
  </head>
  <body bgcolor="#e6e6e6" text="black" link="blue" vlink="blue" alink="blue">
    <table cellpadding="5" cellspacing="5">
      <tr>
        <td width="20%" />
          <td bgcolor="white">
            <center>
              <h1>XmlSimple Tutorial</h1>
              <h3>by Maik Schmidt</h3>
              <h6>Version 1.0.6</h6>
              <hr/>
            </center>
            <h2>Introduction</h2>
            <p>
            Class <em>XmlSimple</em> offers an easy API to read and write XML.
            It is a Ruby translation of Grant McLean's 
            <a href="http://www.cpan.org/modules/by-module/XML/GRANTM/">Perl module XML::Simple</a>.
            Please note, that this tutorial was originally written by Grant
            McLean. I have only converted it to HTML and adjusted it for the
            Ruby version.
            </p>
            <h2>Installation</h2>
            <p>
            You can download <em>XmlSimple</em> <a href="http://www.maik-schmidt.de/projects/xml-simple/dist/">here</a>.
            <em>XmlSimple</em> depends on <a href="http://www.ruby-lang.org/en/raa-list.rhtml?name=REXML">REXML</a>,
            so you will have to install it first. After unpacking the distribution run the following from
            the main directory:
            <pre>
              ruby install.rb config
              ruby install.rb setup
              ruby install.rb install</pre>
            </p>
            <h2>Quick Start</h2>
            <p>
            Say you have a script called <em>foo</em> and a file of configuration options
            called <em>foo.xml</em> containing this:
            <pre>
              &lt;config logdir="/var/log/foo/" debugfile="/tmp/foo.debug"&gt;
                &lt;server name="sahara" osname="solaris" osversion="2.6"&gt;
                  &lt;address&gt;10.0.0.101&lt;/address&gt;
                  &lt;address&gt;10.0.1.101&lt;/address&gt;
                &lt;/server&gt;
                &lt;server name="gobi" osname="irix" osversion="6.5"&gt;
                  &lt;address&gt;10.0.0.102&lt;/address&gt;
                &lt;/server&gt;
                &lt;server name="kalahari" osname="linux" osversion="2.0.34"&gt;
                  &lt;address&gt;10.0.0.103&lt;/address&gt;
                  &lt;address&gt;10.0.1.103&lt;/address&gt;
                &lt;/server&gt;
              &lt;/config&gt;</pre>
            </p>
            <p>
            The following lines of code in <em>foo</em>:
            <pre>
              require 'xmlsimple'
              config = XmlSimple.xml_in('foo.xml', { 'KeyAttr' =&gt; 'name' })</pre>
            will 'slurp' the configuration options into the Hash <em>config</em>
            (if no arguments are passed to <em>xml_in</em> the name and location of
            the XML file will be inferred from name and location of the script).
            You can dump out the contents of the Hash using <code>p config</code>,
            which will produce something like this (formatting has been adjusted
            for brevity):
            <pre>
            {
              'logdir'        =&gt; '/var/log/foo/',
              'debugfile'     =&gt; '/tmp/foo.debug',
              'server'        =&gt; {
                'sahara'        =&gt; {
                  'osversion'     =&gt; '2.6',
                  'osname'        =&gt; 'solaris',
                  'address'       =&gt; [ '10.0.0.101', '10.0.1.101' ]
                },
                'gobi'          =&gt; {
                  'osversion'     =&gt; '6.5',
                  'osname'        =&gt; 'irix',
                  'address'       =&gt; [ '10.0.0.102' ]
                },
                'kalahari'      =&gt; {
                  'osversion'     =&gt; '2.0.34',
                  'osname'        =&gt; 'linux',
                  'address'       =&gt; [ '10.0.0.103', '10.0.1.103' ]
                }
              }
            }</pre>
            Your script could then access the name of the log directory like this:
            <pre>
              puts config['logdir']</pre>
            Similarly, the second address on the server 'kalahari' could be
            referenced as:
            <pre>
              puts config['server']['kalahari']['address'][1]</pre>
            </p>
            <p>
            What could be simpler? (Rhetorical).
            </p>
            <p>
            For simple requirements, that's really all there is to it. If you want
            to store your XML in a different directory or file, or pass it in as a
            string, you'll need to check out the section on <a href="#options">options</a>.
            If you want to turn off or tweak the array folding feature (that neat
            little transformation that produced <em>config['server'])</em> you'll
            find options for that as well.
            </p>
            <p>
            If you want to generate XML (for example to write a modified version of
            <em>config</em> back out as XML), check out <em>xml_out</em>.
            </p>
            <h2>Description</h2>
            <p>
            The <em>XmlSimple</em> class provides a simple API layer on top of the
            <a href="http://www.ruby-lang.org/en/raa-list.rhtml?name=REXML">REXML</a>
            parser. Additionally, two functions are exported: <em>xml_in</em> and
            <em>xml_out</em>.
            </p>
            <p>
            The simplest approach is to call these two functions directly,
            but an optional object oriented interface (see the section on <a href="#OOInterface">"Optional OO Interface"</a>
            below) allows them to be called as methods of an <em>XmlSimple</em> object.
            </p>
            <h3>xml_in</h3>
            <p>
            Parses XML formatted data and returns a reference to a data structure
            which contains the same information in a more readily accessible form.
            (Skip down to the section on <a href="#examples">examples</a> below, for more
            sample code).
            </p>
            <p>
            <em>xml_in</em> accepts an optional XML specifier followed by a Hash
            containing 'name =&gt; value' option pairs. The XML specifier can be
            one of the following:
            </p>
            <ul>
                <li>A filename</li>
            <p>
            If the filename contains no directory components <em>xml_in</em> will look
            for the file in each directory in the searchpath (see the section on
            <a href="#options">options</a> below). For example:
            <pre>
                ref = XmlSimple.xml_in('/etc/params.xml')</pre>
            </p>
            <li>nil</li>
            <p>
            If there is no XML specifier, <em>xml_in</em> will check the script
            directory and each of the searchpath directories for a file with the
            same name as the script but with the extension '.xml'. Note: if you
            wish to specify options, you must specify the value <em>nil</em>:
            <pre>
                ref = XmlSimple.xml_in(nil, { 'ForceArray' =&gt; false })</pre>
            </p>
            <li>A string of XML</li>
            <p>
            A string containing XML (recognised by the presence of '&lt;' and '&gt;'
            characters) will be parsed directly. For example:
            <pre>
                ref = XmlSimple.xml_in('&lt;opt username="bob" password="flurp" /&gt;')</pre>
            </p>
            <li>An IO object</li>
            <p>
            An IO object will be read to EOF and its contents parsed. For example:
            <pre>
                file = File.open('/etc/params.xml')
                ref  = XmlSimple.xml_in(file)</pre>
            </p>
            </ul>
            <h3>xml_out</h3>
            <p>
            Takes a data structure (generally a Hash) and returns an XML encoding
            of that structure. If the resulting XML is parsed using <em>xml_in</em>, it
            will return a data structure equivalent to the original.
            </p>
            <p>
            When translating hashes to XML, hash keys which have a leading '-' will
            be silently skipped. This is the approved method for marking elements of
            a data structure which should be ignored by <em>xml_out</em>. (Note: If these
            items were not skipped the key names would be emitted as element or
            attribute names with a leading '-' which would not be valid XML).
            </p>
            <h3>Caveats</h3>
            <p>
            Some care is required in creating data structures which will be passed
            to <em>xml_out</em>. Hash keys from the data structure will be encoded as
            either XML element names or attribute names. Therefore, you should use
            hash key names which conform to the relatively strict XML naming rules:
            </p>
            <p>
            Names in XML must begin with a letter. The remaining characters may be
            letters, digits, hyphens (-), underscores (_) or full stops (.). It is
            also allowable to include one colon (:) in an element name but this
            should only be used when working with namespaces - a facility well
            beyond the scope of <em>XmlSimple</em>.
            </p>
            <p>
            You can use other punctuation characters in hash values (just not in
            hash keys) however <em>XmlSimple</em> does not support dumping binary
            data.
            </p>
            <p>
            If you break these rules, the current implementation of <em>xml_out</em> will
            simply emit non-compliant XML which will be rejected if you try to read
            it back in. (A later version of <em>XmlSimple</em> might take a more
            proactive approach).
            </p>
            <p>
            Note also that although you can nest hashes and arrays to arbitrary
            levels, recursive data structures are not supported and will cause
            <em>xml_out</em> to raise an exception.
            </p>
            <h2><a name="options">Options</a></h2>
            <p>
            <b>IMPORTANT NOTE FOR USERS OF THE PERL VERSION!</b> The default values
            of some options have changed, some options are not supported and I have
            added new options, too:
            <ul>
                <li>'ForceArray' is <em>true</em> by default.</li>
                <li>'KeyAttr' defaults to <em>[]</em> and not to <em>['name', 'key', 'id']</em>.</li>
                <li>The SAX parts of XML::Simple are currently not supported.</li>
                <li>Namespaces are currently not supported.</li>
                <li>Currently, there is no 'strict mode'.</li>
                <li>'AnonymousTag' is not available in the current Perl version.</li>
                <li>'Indent' is not available in the current Perl version.</li>
                <li>The Perl version does not support so called blessed references
                and raises an exception ("can't encode value of type"), if one is
                used. The Ruby version supports all object types, because every
                object in Ruby has a <em>to_s</em> method.</li>
            </ul>
            </p>
            <p>
            <em>XmlSimple</em> supports a number of options. If you find yourself
            repeatedly having to specify the same options, you might like to
            investigate the section on <a href="#OOInterface">"Optional OO Interface"</a>
            below.
            </p>
            <p>
            Because there are so many options, it's hard for new users to know which
            ones are important, so here are the two you really need to know about:
            <ul>
                <li>Check out 'ForceArray' because you'll almost certainly want to
                leave it on.</li>
                <li>Make sure you know what the 'KeyAttr' option does and what its
                default value is because it may surprise you otherwise.</li>
            </ul>
            </p>
            <p>
            Both <em>xml_in</em> and <em>xml_out</em> expect a single argument followed
            by a Hash containing options. So, an option takes the form of a 'name =&gt;
            value' pair. The options listed below are marked with 'in' if they are
            recognised by <em>xml_in</em> and 'out' if they are recognised by <em>xml_out</em>.
            </p>
            <p>
            Each option is also flagged to indicate whether it is:
            <ul>
                <li>'important' - don't use the module until you understand this</li>
                <li>'handy' - you can skip this on the first time through</li>
                <li>'advanced' - you can skip this on the second time through</li>
                <li>'seldom used' - you'll probably never use this unless you
                were the person that requested the feature</li>
            </ul>
            </p>
            <p>The options are listed alphabetically.</p>
            <p>
            <b>Note</b>: Option names are not case sensitive, so you can use the mixed case
            versions shown here. Additionally, you can put underscores between the
            words (e.g. 'key_attr').
            </p>
            <ul>
            <li><b>AnonymousTag =&gt; 'tag name' (in + out) (seldom used)</b></li>
            <p>
            By default, the tag to declare an anonymous value is 'anon'. Using option
            'AnonymousTag' you can set it to an arbitrary string (that must obey to
            the XML naming rules, of course).
            </p>
                <li><b>Cache =&gt; [ cache scheme(s) ] (in) (advanced)</b></li>
                <p>
                Because loading the REXML parser module and parsing an XML file can
                consume a significant number of CPU cycles, it is often desirable to
                cache the output of <em>xml_in</em> for later reuse.
                </p>
                <p>
                When parsing from a named file, <em>XmlSimple</em> supports a number of
                caching schemes. The 'Cache' option may be used to specify one or
                more schemes (using an anonymous array). Each scheme will be tried
                in turn in the hope of finding a cached pre-parsed representation of
                the XML file. If no cached copy is found, the file will be parsed
                and the first cache scheme in the list will be used to save a copy
                of the results. The following cache schemes have been implemented:
                </p>
                <ul>
                    <li><b>storable</b></li>
                    <p>
                    Utilises Marshal to read/write a cache file with the same
                    name as the XML file but with the extension <em>.stor</em>.
                    </p>
                    <li><b>mem_share</b></li>
                    <p>
                    When a file is first parsed, a copy of the resulting data
                    structure is retained in memory in <em>XmlSimple</em>'s
                    namespace. Subsequent calls to parse the same file will return a
                    reference to this structure. This cached version will persist
                    only for the life of the Ruby interpreter (which in the case of
                    mod_ruby for example, may be some significant time).
                    </p>
                    <p>
                    Because each caller receives a reference to the same data
                    structure, a change made by one caller will be visible to all.
                    For this reason, the reference returned should be treated as
                    read-only.
                    </p>
                    <li><b>mem_copy</b></li>
                    <p>
                    This scheme works identically to 'mem_share' (above) except that
                    each caller receives a reference to a new data structure which
                    is a copy of the cached version. Copying the data structure will
                    add a little processing overhead, therefore this scheme should
                    only be used where the caller intends to modify the data
                    structure (or wishes to protect itself from others who might).
                    This scheme uses the Marshal module to perform the copy.
                    </p>
                    <p>
                    <b>Warning!</b> The memory-based caching schemes compare the timestamp on
                    the file to the time when it was last parsed. If the file is stored
                    on an NFS filesystem (or other network share) and the clock on the
                    file server is not exactly synchronised with the clock where your
                    script is run, updates to the source XML file may appear to be
                    ignored.
                    </p>
                </ul>
                <li><b>ContentKey =&gt; 'keyname' (in + out) (seldom used)</b></li>
                <p>
                When text content is parsed to a hash value, this option let's you
                specify a name for the hash key to override the default 'content'.
                So for example:
                <pre>    XmlSimple.xml_in('&lt;opt one="1"&gt;Text&lt;/opt&gt;', { 'ContentKey' =&gt; 'text' })</pre>
                </p>
                <p>
                will parse to:
                <pre>    { 'one' =&gt; '1', 'text' =&gt; 'Text' }</pre>
                </p>
                <p>
                instead of:
                <pre>    { 'one' =&gt; '1', 'content' =&gt; 'Text' }</pre>
                </p>
                <p>
                <em>xml_out</em> will also honour the value of this option when converting
                a hash to XML.
                </p>
                <p>
                You can also prefix your selected key name with a '-' character to
                have <em>xml_in</em> try a little harder to eliminate unnecessary
                'content' keys after array folding. For example:
                </p>
                <pre>
                  XmlSimple.xml_in(%q(
                    &lt;opt&gt;
                      &lt;item name="one"&gt;First&lt;item&gt;
                      &lt;item name="two"&gt;Second&lt;item&gt;
                    &lt;opt&gt;), {
                  'KeyAttr'    =&gt; { 'item' =&gt; 'name' }, 
                  'ForceArray' =&gt; [ 'item' ],
                  'ContentKey' =&gt; '-content'
                })</pre>
                <p>
                will parse to:
                </p>
                <pre>
                {
                  'item' =&gt; {
                    'one'  =&gt;  'First',
                    'two'  =&gt;  'Second'
                  }
                }</pre>
                <p>
                rather than this (without the '-'):
                </p>
                <pre>
                {
                  'item' =&gt; {
                    'one'  =&gt; { 'content' =&gt; 'First' },
                    'two'  =&gt; { 'content' =&gt; 'Second' }
                  }
                }</pre>
            <li><b>ForceArray =&gt; true | false (in) (IMPORTANT!)</b></li>
            <p>
            This option should be set to <em>true</em> to force nested elements to be
            represented as arrays even when there is only one. For example, with
            'ForceArray' enabled, this XML:
            <pre>                
            &lt;opt&gt;
              &lt;name&gt;value&lt;/name&gt;
            &lt;/opt&gt;</pre>
            </p>
            <p>
            would parse to this:
            <pre>
            {
              'name' =&gt; [ 'value' ]
            }</pre>
            </p>
            <p>
            instead of this (the default):
            <pre>
            {
              'name' =&gt; 'value'
            }</pre>
            </p>
            <p>
            This option is especially useful if the data structure is likely to
            be written back out as XML and the default behaviour of rolling
            single nested elements up into attributes is not desirable.
            </p>
            <p>
            If you are using the array folding feature, you should almost
            certainly enable this option. If you do not, single nested elements
            will not be parsed to arrays and therefore will not be candidates
            for folding to a hash.
            </p>
            <p>The option is <em>true</em> by default.</p>
            <li><b>ForceArray =&gt; [ name(s) ] (in) (IMPORTANT!)</b></li>
            <p>
            This alternative form of the 'ForceArray' option allows you to
            specify a list of element names which should always be forced into
            an array representation, rather than the 'all or nothing' approach
            above.
            </p>
            <p>
        It is also possible to include compiled regular
        expressions in the list - any element names which match the pattern
        will be forced to arrays. If the list contains only a single regex,
        then it is not necessary to enclose it in an Array. E.g.
        </p>
        <pre>
            'ForceArray' =&gt; %r(_list$)</pre>
            <li><b>ForceContent (in) (seldom used)</b></li>
            <p>
            When <em>xml_in</em> parses elements which have text content as well as
            attributes, the text content must be represented as a hash value
            rather than a simple scalar. This option allows you to force text
            content to always parse to a hash value even when there are no
            attributes. So for example:
            <pre>
              xml =%q(
                &lt;opt&gt;
                  &lt;x&gt;text1&lt;/x&gt;
                  &lt;y a="2"&gt;text2&lt;/y&gt;
                &lt;/opt&gt;)
              XmlSimple.xml_in(xml, { 'ForceContent' =&gt; true })</pre>
            </p>
            <p>
            will parse to:
            <pre>
                {
                  'x' =&gt; {             'content' =&gt; 'text1' },
                  'y' =&gt; { 'a' =&gt; '2', 'content' =&gt; 'text2' }
                }</pre>
            </p>
            <p>
            instead of:
            <pre>
                {
                  'x' =&gt; 'text1',
                  'y' =&gt; { 'a' =&gt; '2', 'content' =&gt; 'text2' }
                }</pre>
            </p>
            <li><b>GroupTags =&gt; { grouping tag =&gt; grouped tag } (in + out) (handy)</b></li>
            <p>
        You can use this option to eliminate extra levels of indirection in
        your Ruby data structure. For example this XML:
        </p>
        <pre>
          xml = %q(
          &lt;opt&gt;
            &lt;searchpath&gt;
              &lt;dir&gt;usr/bin&lt;dir&gt;
              &lt;dir&gt;usr/local/bin&lt;dir&gt;
              &lt;dir&gt;usr/X11/bin&lt;dir&gt;
            &lt;searchpath&gt;
          &lt;opt&gt;)</pre>
         <p>
         Would normally be read into a structure like this:
         </p>
         <pre>
          {
            'searchpath' =&gt; {
              'dir' =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
            }
          }</pre>
      <p>
      But when read in with the appropriate value for 'GroupTags':
      </p>
      <pre>
          opt = XmlSimple.xml_in(xml, { 'GroupTags' =&gt; { 'searchpath' =&gt; 'dir' })</pre>
      <p>
      It will return this simpler structure:
      </p>
      <pre>
          {
            'searchpath' =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
          }</pre>
      <p>
        You can specify multiple 'grouping element' to 'grouped element'
        mappings in the same Hash. If this option is combined with
        'KeyAttr', the array folding will occur first and then the grouped
        element names will be eliminated.
        </p>
        <p>
        <em>xml_out</em> will also use the grouptag mappings to re-introduce the
        tags around the grouped elements. Beware though that this will occur
        in all places that the 'grouping tag' name occurs - you probably
        don't want to use the same name for elements as well as attributes.
        </p>
        <li><b>Indent =&gt; 'string' (out) (seldom used)</b></li>
        <p>
        By default <em>xml_out</em>'s pretty printing mode indents the output
        document using two blanks. 'Indent' allows you to use an arbitrary
        string for indentation.
        </p>
        <p>
        If the 'NoIndent' option is set, 'Indent' will be ignored.
        </p>
        <li><b>KeepRoot =&gt; true | false (in + out) (handy)</b></li>
            <p>
            In its attempt to return a data structure free of superfluous detail
            and unnecessary levels of indirection, <em>xml_in</em> normally discards the
            root element name. Setting the 'KeepRoot' option to <em>true</em> will
            cause the root element name to be retained. So after executing this
            code:
            <pre>
                config = XmlSimple.xml_in('&lt;config tempdir="/tmp" /&gt;', { 'KeepRoot' =&gt; true })</pre>
            </p>
            <p>
            you'll be able to reference the tempdir as <em>config['config']['tempdir']</em>
            instead of the default <em>config['tempdir']</em>.
            </p>
            <p>Similarly, setting the 'KeepRoot' option to <em>true</em> will tell
            <em>xml_out</em> that the data structure already contains a root element name
            and it is not necessary to add another.
            </p>
            <li><b>KeyAttr =&gt; [ list ] (in + out) (IMPORTANT!)</b></li>
                <p>
                This option controls the 'array folding' feature which translates
                nested elements from an array to a hash. For example, this XML:
                <pre>
                    &lt;opt&gt;
                      &lt;user login="grep" fullname="Gary R Epstein" /&gt;
                      &lt;user login="stty" fullname="Simon T Tyson" /&gt;
                    &lt;/opt&gt;</pre>

                would, by default, parse to this:
            <pre>
            {
              'user' =&gt; [
                 {
                   'login'    =&gt; 'grep',
                   'fullname' =&gt; 'Gary R Epstein'
                 },
                 {
                   'login'    =&gt; 'stty',
                   'fullname' =&gt; 'Simon T Tyson'
                 }
               ]
            }</pre>
            </p>
            <p>
            If the option 'KeyAttr =&gt; "login"' were used to specify that
            the 'login' attribute is a key, the same XML would parse to:
            <pre>
            {
              'user' =&gt; {
                'stty' =&gt; {
                  'fullname' =&gt; 'Simon T Tyson'
                },
                'grep' =&gt; {
                  'fullname' =&gt; 'Gary R Epstein'
                }
              }
            }</pre>
            </p>
            <p>
            The key attribute names should be supplied in an array if there is
            more than one. <em>xml_in</em> will attempt to match attribute names
            in the order supplied. <em>xml_out</em> will use the first attribute
            name supplied when 'unfolding' a hash into an array.
            </p>
            <p>
            <b>Note:</b> the 'KeyAttr' option controls the folding of arrays. By
            default a single nested element will be rolled up into a scalar rather
            than an array and therefore will not be folded. Use the 'ForceArray'
            option to force nested elements to be parsed into arrays and
            therefore candidates for folding into hashes.
            </p>
            <p>
            The default value for 'KeyAttr' is <em>[]</em>, i.e. the array folding feature
            is disabled.
            </p>
            <li><b>KeyAttr =&gt; { list } (in + out) (IMPORTANT!)</b></li>
            <p>
            This alternative method of specifiying the key attributes allows
            more fine grained control over which elements are folded and on
            which attributes. For example the option 'KeyAttr =&gt; { 'package' =&gt;
            'id' } will cause any package elements to be folded on the 'id'
            attribute. No other elements which have an 'id' attribute will be
            folded at all.
            </p>
            <p>
            <b>Note:</b> <em>xml_in</em> will generate a warning if this syntax is
            used and an element which does not have the specified key attribute is
            encountered (e.g.: a 'package' element without an 'id' attribute, to
            use the example above).
            </p>
            <p>
            Two further variations are made possible by prefixing a '+' or a '-'
            character to the attribute name:
            </p>
            <p>
            The option
            <pre>
              'KeyAttr' =&gt; { 'user' =&gt; "+login" }'</pre>
            will cause this XML:
            <pre>
            &lt;opt&gt;
              &lt;user login="grep" fullname="Gary R Epstein" /&gt;
              &lt;user login="stty" fullname="Simon T Tyson" /&gt;
            &lt;/opt&gt;</pre>
            </p>
            <p>
            to parse to this data structure:
            <pre>
            {
              'user' =&gt; {
                'stty' =&gt; {
                  'fullname' =&gt; 'Simon T Tyson',
                  'login'    =&gt; 'stty'
                },
                'grep' =&gt; {
                  'fullname' =&gt; 'Gary R Epstein',
                  'login'    =&gt; 'grep'
                }
              }
            }</pre>
            </p>
            <p>
            The '+' indicates that the value of the key attribute should be
            copied rather than moved to the folded hash key.
            </p>
            <p>
            A '-' prefix would produce this result:
            <pre>
            {
              'user' =&gt; {
                'stty' =&gt; {
                  'fullname' =&gt; 'Simon T Tyson',
                  '-login'   =&gt; 'stty'
                },
                'grep' =&gt; {
                  'fullname' =&gt; 'Gary R Epstein',
                  '-login'   =&gt; 'grep'
                }
              }
            }</pre>
            </p>
            <p>
            As described earlier, <em>xml_out</em> will ignore hash keys starting with a
            '-'.
            </p>
            <li><b>NoAttr =&gt; true | false (in + out) (handy)</b></li>
            <p>
            When used with <em>xml_out</em>, the generated XML will contain no attributes.
            All hash key/values will be represented as nested elements instead.
            </p>
            <p>
            When used with <em>xml_in</em>, any attributes in the XML will be ignored.
            </p>
            <li><b>NormaliseSpace =&gt; 0 | 1 | 2 (in) (handy)</b></li>
            <p>
        This option controls how whitespace in text content is handled.
        Recognised values for the option are:
        </p>
        <ul>
            <li>0</li>
            <p>The default behaviour is for whitespace to be passed through
            unaltered (except of course for the normalisation of whitespace
            in attribute values which is mandated by the XML recommendation).
            </p>
            <li>1</li>
            <p>Whitespace is normalised in any value used as a hash key
            (normalising means removing leading and trailing whitespace and
            collapsing sequences of whitespace characters to a single space).
            </p>
            <li>2</li>
            <p>Whitespace is normalised in all text content.</p>
            </ul>
        <p>Note: you can spell this option with a 'z' if that is more natural
        for you.</p>
            <li><b>NoEscape =&gt; true | false (out) (seldom used)</b></li>
            <p>
            By default, <em>xml_out</em> will translate the characters &lt;,
            &gt;, &amp;, &apos;, and " to '&amp;lt;', '&amp;gt;',
            '&amp;amp', '&amp;apos', and '&amp;quot' respectively. Use this
            option to suppress escaping (presumably because you've already escaped
            the data in some more sophisticated manner).
            </p>
            <li><b>NoIndent =&gt; true | false (out) (seldom used)</b></li>
            <p>
            Set this option to <em>true</em> to disable <em>xml_out</em>'s default 'pretty
        printing' mode. With this option enabled, the XML output will all be
        on one line (unless there are newlines in the data) - this may be
        easier for downstream processing.
        </p>
        <li><b>OutputFile =&gt; &lt;file specifier&gt; (out) (handy)</b></li>
            <p>
            The default behaviour of <em>xml_out</em> is to return the XML as a
            string. If you wish to write the XML to a file, simply supply the
            filename using the 'OutputFile' option. Alternatively, you can
            supply an object derived from IO instead of a filename.
            </p>
            <li><b>RootName =&gt; 'string' (out) (handy)</b></li>
            <p>
            By default, when <em>xml_out</em> generates XML, the root element will be
            named 'opt'. This option allows you to specify an alternative name.
            </p>
            <p>
            Specifying either <em>nil</em> or the empty string for the 'RootName' option
            will produce XML with no root elements. In most cases the resulting
            XML fragment will not be 'well formed' and therefore could not be
            read back in by <em>xml_in</em>. Nevertheless, the option has been found
            to be useful in certain circumstances.
            </p>
            <li><b>SearchPath =&gt; [ list ] (in) (handy)</b></li>
            <p>
            Where the XML is being read from a file, and no path to the file is
            specified, this attribute allows you to specify which directories
            should be searched.
            </p>
            <p>
            If the first parameter to <em>xml_in</em> is undefined, the default
            searchpath will contain only the directory in which the script
            itself is located. Otherwise the default searchpath will be empty.
            </p>
            <p>
            <b>Note:</b> the current directory ('.') is not searched unless it is the
            directory containing the script.</p>
            <li><b>SuppressEmpty =&gt; true | '' | nil (in + out) (handy)</b></li>
            <p>
            This option controls what <em>xml_in</em> should do with empty elements
            (no attributes and no content). The default behaviour is to represent
            them as empty hashes. Setting this option to <em>true</em> will cause
            empty elements to be skipped altogether. Setting the option to <em>nil</em>
            or the empty string will cause empty elements to be represented as <em>nil</em>
            or the empty string respectively. The latter two alternatives are a
            little easier to test for in your code than a hash with no keys.
            </p>
            <li><b>Variables =&gt; { name =&gt; value } (in) (handy)</b></li>
            <p>
        This option allows variables in the XML to be expanded when the file
        is read. (there is no facility for putting the variable names back
        if you regenerate XML using <em>xml_out</em>).
        </p>
        <p>
        A 'variable' is any text of the form "${name}" which occurs in an
        attribute value or in the text content of an element. If 'name'
        matches a key in the supplied Hash, "${name}" will be replaced
        with the corresponding value from the Hash. If no matching key is
        found, the variable will not be replaced.
        </p>
            <li><b>VarAttr =&gt; 'attr_name' (in) (handy)</b></li>
            <p>
        In addition to the variables defined using 'Variables', this option
        allows variables to be defined in the XML. A variable definition
        consists of an element with an attribute called 'attr_name' (the
        value of the 'VarAttr' option). The value of the attribute will be
        used as the variable name and the text content of the element will
        be used as the value. A variable defined in this way will override a
        variable defined using the 'Variables' option. For example:
        </p>
        <pre>
            XmlSimple.xml_in(%q(&lt;opt&gt;
                    &lt;dir name="prefix"&gt;usr/local/apache&lt;dir&gt;
                    &lt;dir name="exec_prefix"&gt;prefix}&lt;dir&gt;
                    &lt;dir name="bindir"&gt;exec_prefix}/bin&lt;dir&gt;
                    &lt;opt&gt;), {
                 'VarAttr' =&gt; 'name', 'ContentKey' =&gt; '-content'
                 })</pre>
             <p>
             produces the following data structure:
             </p>
             <pre>
          {
            'dir' =&gt; {
                     'prefix'      =&gt; '/usr/local/apache',
                     'exec_prefix' =&gt; '/usr/local/apache',
                     'bindir'      =&gt; '/usr/local/apache/bin',
                   }
          }</pre>
            <li><b>XmlDeclaration =&gt; <em>true</em> | 'string' (out) (handy)</b></li>
            <p>
            If you want the output from <em>xml_out</em> to start with the optional
            XML declaration, simply set the option to <em>true</em>. The default XML
            declaration is:
            <pre>
                &lt;?xml version='1.0' standalone='yes'?&gt;</pre>
            </p>
            <p>
            If you want some other string (for example to declare an encoding
            value), set the value of this option to the complete string you
            require.
            </p>
            </ul>
            <h2><a name="OOInterface">Optional OO Interface</a></h2>
            <p>
            The procedural interface is both simple and convenient, but if you have
            to define a set of default values which should be used on all subsequent
            calls to <em>xml_in</em> or <em>xml_out</em></li>, you might prefer to
            use the object oriented (OO) interface.
            </p>
            <p>
            The default values for the options described above are unlikely to suit
            everyone. The OO interface allows you to effectively override
            <em>XmlSimple</em>'s defaults with your preferred values. It works like this:
            </p>
            <p>
            First create an <em>XmlSimple</em> parser object with your preferred
            defaults:
            <pre>
                xs = XmlSimple.new({ 'ForceArray' =&gt; false, 'KeepRoot' =&gt; true)</pre>
            </p>
            <p>
            then call <em>xml_in</em> or <em>xml_out</em> as a method of that object:
            <pre>
                ref = xs.xml_in(xml)
                xml = xs.xml_out(ref)</pre>
            </p>
            <p>
            You can also specify options when you make the method calls and these
            values will be merged with the values specified when the object was
            created. Values specified in a method call take precedence.
            </p>
            <h2>Error Handling</h2>
            <p>
            The XML standard is very clear on the issue of non-compliant documents.
            An error in parsing any single element (for example a missing end tag)
            must cause the whole document to be rejected. <em>XmlSimple</em> will
            raise an appropriate exception if it encounters a parsing error.
            </p>
            <h2><a name="examples">Examples</a></h2>
            <p>
            When <em>xml_in</em> reads the following very simple piece of XML:
            <pre>
                &lt;opt username="testuser" password="frodo"&gt;&lt;/opt&gt;</pre>
            </p>
            <p>
            it returns the following data structure:
            <pre>
                {
                  'username' =&gt; 'testuser',
                  'password' =&gt; 'frodo'
                }</pre>
            </p>
            <p>
            The identical result could have been produced with this alternative XML:
            <pre>
                &lt;opt username="testuser" password="frodo" /&gt;</pre>
            </p>
            <p>
            Or this (although see 'ForceArray' option for variations):
            <pre>
                &lt;opt&gt;
                  &lt;username&gt;testuser&lt;/username&gt;
                  &lt;password&gt;frodo&lt;/password&gt;
                &lt;/opt&gt;</pre>
            </p>
            <p>
            Repeated nested elements are represented as anonymous arrays:
            <pre>
                &lt;opt&gt;
                  &lt;person firstname="Joe" lastname="Smith"&gt;
                    &lt;email&gt;joe@smith.com&lt;/email&gt;
                    &lt;email&gt;jsmith@yahoo.com&lt;/email&gt;
                  &lt;/person&gt;
                  &lt;person firstname="Bob" lastname="Smith"&gt;
                    &lt;email&gt;bob@smith.com&lt;/email&gt;
                  &lt;/person&gt;
                &lt;/opt&gt;
         
                {
                  'person' =&gt; [
                    {
                      'email' =&gt; [
                        'joe@smith.com',
                        'jsmith@yahoo.com'
                      ],
                      'firstname' =&gt; 'Joe',
                      'lastname' =&gt; 'Smith'
                    },
                    {
                      'email' =&gt; ['bob@smith.com'],
                      'firstname' =&gt; 'Bob',
                      'lastname' =&gt; 'Smith'
                    }
                  ]
                }</pre>
              </p>
              <p>
              Nested elements with a recognised key attribute are transformed (folded)
              from an array into a hash keyed on the value of that attribute, i.e.
              calling <em>xml_in</em> with the 'KeyAttr' set to <em>[key]</em> will 
              transform
              <pre>
                  &lt;opt&gt;
                    &lt;person key="jsmith" firstname="Joe" lastname="Smith" /&gt;
                    &lt;person key="tsmith" firstname="Tom" lastname="Smith" /&gt;
                    &lt;person key="jbloggs" firstname="Joe" lastname="Bloggs" /&gt;
                  &lt;/opt&gt;</pre>
              into
              <pre>
                  {
                    'person' =&gt; {
                      'jbloggs' =&gt; {
                        'firstname' =&gt; 'Joe',
                        'lastname' =&gt; 'Bloggs'
                      },
                      'tsmith' =&gt; {
                        'firstname' =&gt; 'Tom',
                        'lastname' =&gt; 'Smith'
                      },
                      'jsmith' =&gt; {
                        'firstname' =&gt; 'Joe',
                        'lastname' =&gt; 'Smith'
                      }
                    }
                  }</pre>
              </p>
              <p>
              The &lt;anon&gt; tag can be used to form anonymous arrays:
              <pre>
                  &lt;opt&gt;
                    &lt;head&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;anon&gt;Col 3&lt;/anon&gt;&lt;/head&gt;
                    &lt;data&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;anon&gt;R1C3&lt;/anon&gt;&lt;/data&gt;
                    &lt;data&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;anon&gt;R2C3&lt;/anon&gt;&lt;/data&gt;
                    &lt;data&gt;&lt;anon&gt;R3C1&lt;/anon&gt;&lt;anon&gt;R3C2&lt;/anon&gt;&lt;anon&gt;R3C3&lt;/anon&gt;&lt;/data&gt;
                  &lt;/opt&gt;
                  
                  {
                    'head' =&gt; [
                      [ 'Col 1', 'Col 2', 'Col 3' ]
                    ],
                    'data' =&gt; [
                      [ 'R1C1', 'R1C2', 'R1C3' ],
                      [ 'R2C1', 'R2C2', 'R2C3' ],
                      [ 'R3C1', 'R3C2', 'R3C3' ]
                    ]
                  }</pre>
                </p>
                <p>
                Anonymous arrays can be nested to arbirtrary levels and as a special
                case, if the surrounding tags for an XML document contain only an
                anonymous array the array will be returned directly rather than the
                usual hash:
                <pre>
                    &lt;opt&gt;
                      &lt;anon&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;/anon&gt;
                      &lt;anon&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;/anon&gt;
                      &lt;anon&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;/anon&gt;
                    &lt;/opt&gt;
                    
                    [
                      [ 'Col 1', 'Col 2' ],
                      [ 'R1C1', 'R1C2' ],
                      [ 'R2C1', 'R2C2' ]
                    ]</pre>
                </p>
                <p>
                Elements which only contain text content will simply be represented as a
                scalar. Where an element has both attributes and text content, the
                element will be represented as a hash with the text content in the
                'content' key:
                <pre>
                    &lt;opt&gt;
                      &lt;one&gt;first&lt;/one&gt;
                      &lt;two attr="value"&gt;second&lt;/two&gt;
                    &lt;/opt&gt;
                    
                    {
                      'one' =&gt; 'first',
                      'two' =&gt; { 'attr' =&gt; 'value', 'content' =&gt; 'second' }
                    }</pre>
                </p>
                <p>
                Mixed content (elements which contain both text content and nested
                elements) will be not be represented in a useful way - element order and
                significant whitespace will be lost. If you need to work with mixed
                content, then <em>XmlSimple</em> is not the right tool for your job - check
                out the next section.
                </p>
                <h2><a name="further">Where to from here?</a></h2>
                <p>
                <em>XmlSimple</em> is by nature very simple.
                </p>
                <ul>
                    <li>The parsing process liberally disposes of 'surplus' whitespace -
                    some applications will be sensitive to this.</li>
                    <li>Slurping data into a hash will implicitly discard information about
                    attribute order. Normally this would not be a problem because any items
                    for which order is important would typically be encoded as elements
                    rather than attributes. However <em>XmlSimple</em>'s aggressive slurping and
                    folding algorithms can defeat even these techniques.</li>
                    <li>The API offers little control over the output of <em>xml_out</em>. In
                    particular, it is not especially likely that feeding the output from
                    <em>xml_in</em> into <em>xml_out</em> will reproduce the original XML (although
                    passing the output from <em>xml_out</em> into <em>xml_in</em> should reproduce
                    the original data structure).</li>
                    <li><em>xml_out</em> cannot produce well formed HTML unless you feed it with
                    care - hash keys must conform to XML element naming rules and
                    <em>nil</em> values should be avoided.</li>
                    <li><em>xml_out</em> does not currently support encodings (although it shouldn't
                    stand in your way if you feed it encoded data).</li>
                    <li>If you're attempting to get the output from <em>xml_out</em> to conform to
                    a specific DTD, you're almost certainly using the wrong tool for the job.</li>
                </ul>
                <p>
                If any of these points are a problem for you, then <em>XmlSimple</em> is
                probably not the right class for your application.
                </p>
            <h2>Further Reading</h2>
            <p>If you are interested in absolute truth, you will have to
            look at the source code or the <a href="api/index.html">API docs.</a></p>
            <h2>Acknowledgements</h2>
            <p>
              A big "Thank you!" goes to
              <ul>
                <li>Grant McLean for Perl's <a href="http://www.cpan.org/modules/by-module/XML/GRANTM/">XML::Simple</a></li>
                <li>Yukihiro Matsumoto for Ruby.</li>
                <li>Sean Russell for REXML.</li>
                <li>Dave Thomas for Rdoc.</li>
                <li>Nathaniel Talbott for Test::Unit.</li>
                <li>Minero Aoki for his setup package.</li>
              </ul>
            </p>
            <h2>Contact</h2>
            <p>
              If you have any suggestions or want to report bugs, please
              contact me (<a href='mailto:contact@maik-schmidt.de'>contact@maik-schmidt.de</a>).
            </p>
            <hr/>
            <center>Copyright &copy; 2003 by Grant McLean &amp; Maik Schmidt.</center>
          </td>
          <td width="20%" />
        </tr>
      </table>
    </body>
</html>
